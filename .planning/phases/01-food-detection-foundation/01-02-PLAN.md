---
phase: 01-food-detection-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - knowledge-graph/schema.sql
  - knowledge-graph/seed_recipenlg.py
  - knowledge-graph/seed_usda.py
  - knowledge-graph/query.py
  - knowledge-graph/export_mobile.py
  - knowledge-graph/requirements.txt
  - knowledge-graph/tests/test_queries.py
autonomous: true

must_haves:
  truths:
    - "Given a dish name, the system returns all nutrition-significant ingredients with weight percentages"
    - "Dish variants are linked (e.g. 'nasi goreng' is a variant of 'fried rice' with different seasoning profile)"
    - "Knowledge graph contains dishes from Western AND East Asian cuisines"
    - "Ingredients link to USDA FDC IDs for downstream nutrient lookup"
    - "The knowledge graph is exportable as a single mobile-ready SQLite file"
  artifacts:
    - path: "knowledge-graph/schema.sql"
      provides: "SQLite schema with dishes, ingredients, dish_ingredients, and variant relationships"
      contains: "CREATE TABLE dishes"
    - path: "knowledge-graph/seed_recipenlg.py"
      provides: "RecipeNLG parsing and import into knowledge graph"
    - path: "knowledge-graph/seed_usda.py"
      provides: "USDA FoodData Central prepared food ingredient import"
    - path: "knowledge-graph/query.py"
      provides: "Recursive CTE queries for dish->ingredient traversal"
      contains: "WITH RECURSIVE"
    - path: "knowledge-graph/export_mobile.py"
      provides: "Export optimized SQLite DB for mobile bundling"
  key_links:
    - from: "knowledge-graph/query.py"
      to: "knowledge-graph/schema.sql"
      via: "SQLite queries against the schema tables"
      pattern: "dish_ingredients.*JOIN.*ingredients"
    - from: "knowledge-graph/seed_recipenlg.py"
      to: "knowledge-graph/schema.sql"
      via: "INSERT statements populating dishes and ingredients tables"
      pattern: "INSERT INTO dishes"
---

<objective>
Build the food knowledge graph in SQLite: schema for dish->ingredient->nutrient relationships with variant tracking, seed from RecipeNLG (2.2M recipes) and USDA FoodData Central, and create query API + mobile export.

Purpose: Hidden ingredient inference is a core Phase 1 requirement. When the detection pipeline identifies "carbonara", the knowledge graph must return egg, pancetta, parmesan, black pepper, pasta, cream, etc. with weight proportions. This is independent of the ML pipeline and can be built in parallel.

Output: Populated SQLite knowledge graph with query API, test suite, and mobile-ready export at `knowledge-graph/food-knowledge.db`.
</objective>

<execution_context>
@/Users/jting/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jting/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-food-detection-foundation/01-RESEARCH.md
@.planning/phases/01-food-detection-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLite knowledge graph schema and seed from RecipeNLG + USDA</name>
  <files>
    knowledge-graph/requirements.txt
    knowledge-graph/schema.sql
    knowledge-graph/seed_recipenlg.py
    knowledge-graph/seed_usda.py
  </files>
  <action>
Build the knowledge graph foundation:

1. Create `knowledge-graph/requirements.txt`:
   - requests>=2.31.0 (USDA API calls)
   - tqdm (progress bars)
   - datasets>=2.14.0 (HuggingFace datasets for RecipeNLG download)

2. Create `knowledge-graph/schema.sql` implementing the research-recommended schema:
   ```sql
   CREATE TABLE dishes (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       name TEXT UNIQUE NOT NULL,
       canonical_id INTEGER REFERENCES dishes(id),  -- variant-of relationship
       cuisine TEXT,                                  -- Western, Chinese, Japanese, Korean, Vietnamese, Thai, Indian, Other
       source TEXT NOT NULL DEFAULT 'recipenlg',      -- recipenlg, usda, user_correction
       confidence REAL DEFAULT 0.5,
       created_at TEXT DEFAULT (datetime('now')),
       updated_at TEXT DEFAULT (datetime('now'))
   );

   CREATE TABLE ingredients (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       name TEXT UNIQUE NOT NULL,
       usda_fdc_id INTEGER,                          -- USDA FoodData Central ID for nutrient lookup
       category TEXT,                                 -- protein, grain, vegetable, oil, seasoning, dairy, etc.
       created_at TEXT DEFAULT (datetime('now'))
   );

   CREATE TABLE dish_ingredients (
       dish_id INTEGER REFERENCES dishes(id) ON DELETE CASCADE,
       ingredient_id INTEGER REFERENCES ingredients(id) ON DELETE CASCADE,
       weight_pct REAL,                              -- proportion of total dish weight (0.0-1.0)
       is_nutrition_significant BOOLEAN DEFAULT 1,   -- FALSE for garnishes/trace amounts
       typical_amount_g REAL,                        -- typical weight in grams for standard serving
       source TEXT NOT NULL DEFAULT 'recipenlg',
       confidence REAL DEFAULT 0.5,
       PRIMARY KEY (dish_id, ingredient_id)
   );

   -- Indexes for common queries
   CREATE INDEX idx_dishes_cuisine ON dishes(cuisine);
   CREATE INDEX idx_dishes_canonical ON dishes(canonical_id);
   CREATE INDEX idx_ingredients_usda ON ingredients(usda_fdc_id);
   CREATE INDEX idx_dish_ingredients_dish ON dish_ingredients(dish_id);
   ```
   Include FTS5 virtual table for fuzzy dish name search:
   ```sql
   CREATE VIRTUAL TABLE dishes_fts USING fts5(name, cuisine, content=dishes, content_rowid=id);
   ```

3. Create `knowledge-graph/seed_recipenlg.py`:
   - Download RecipeNLG from HuggingFace: `load_dataset("mbien/recipe_nlg")`
   - For each recipe, extract:
     - `title` -> `dishes.name` (normalize: lowercase, strip extra whitespace)
     - `ingredients` list -> parse each into ingredient name + amount
     - `ner` (named entity recognition tags) -> use for structured ingredient extraction
   - Deduplicate dish names (many recipes for "chocolate cake" -- merge ingredient lists, average proportions)
   - For each unique dish:
     - Insert into `dishes` table
     - Parse ingredients using the NER tags from RecipeNLG (already structured)
     - Calculate approximate weight_pct from ingredient amounts (convert cups/tbsp/etc to grams using standard conversion table)
     - Insert into `dish_ingredients`
   - Assign cuisine labels using a hardcoded mapping of ~200 keywords (same approach as audit_cuisines.py):
     - "sushi", "ramen", "tempura" -> Japanese
     - "pad thai", "green curry" -> Thai
     - "kimchi", "bibimbap" -> Korean
     - "pho", "banh mi" -> Vietnamese
     - "fried rice", "dim sum", "kung pao" -> Chinese
     - etc.
   - Link dish variants: if two dish names are similar (e.g., "chicken fried rice" and "fried rice"), set `canonical_id` on the more specific one pointing to the more generic one
   - Log progress: total recipes processed, unique dishes created, total ingredient entries, cuisine distribution
   - Target: process all 2.2M recipes, creating ~5K-20K unique dish entries

4. Create `knowledge-graph/seed_usda.py`:
   - Query USDA FoodData Central API (`https://api.nal.usda.gov/fdc/v1/`) using DEMO_KEY
   - Search for prepared/mixed food items (dataType: "Survey (FNDDS)")
   - For each USDA prepared food entry:
     - If the dish already exists in our DB (fuzzy match on name), update with USDA data
     - If new, create dish entry with source='usda'
     - Extract `inputFoods` (USDA's list of component ingredients for prepared foods)
     - Map each input food to our ingredients table, setting `usda_fdc_id`
     - Calculate weight_pct from USDA's `gramWeight` values
   - Rate limiting: DEMO_KEY allows 30 requests/hour, 1000/day. Use proper delays.
   - Save API responses to `knowledge-graph/cache/usda_responses/` for re-runs without re-fetching
   - Log: dishes updated with USDA data, new dishes added, ingredient->FDC ID mappings created

Important: RecipeNLG ingredient parsing does NOT need to be perfect. The goal is a reasonable first pass that covers the most common dishes. User corrections will refine over time (per locked decision).
  </action>
  <verify>
- `sqlite3 knowledge-graph/food-knowledge.db ".tables"` shows dishes, ingredients, dish_ingredients, dishes_fts
- `sqlite3 knowledge-graph/food-knowledge.db "SELECT COUNT(*) FROM dishes"` returns >1000 dishes
- `sqlite3 knowledge-graph/food-knowledge.db "SELECT cuisine, COUNT(*) FROM dishes GROUP BY cuisine"` shows distribution across cuisines
- `sqlite3 knowledge-graph/food-knowledge.db "SELECT COUNT(*) FROM ingredients WHERE usda_fdc_id IS NOT NULL"` shows ingredients with USDA links
- Spot check: `sqlite3 knowledge-graph/food-knowledge.db "SELECT i.name, di.weight_pct FROM dish_ingredients di JOIN ingredients i ON i.id = di.ingredient_id JOIN dishes d ON d.id = di.dish_id WHERE d.name = 'fried rice' ORDER BY di.weight_pct DESC"` returns sensible ingredients
  </verify>
  <done>
- SQLite schema created with dishes, ingredients, dish_ingredients tables + FTS5 search
- RecipeNLG parsed: >1000 unique dishes with ingredient breakdowns
- USDA prepared foods imported with FDC ID mappings
- Cuisine labels assigned to dishes with coverage of priority cuisines
- Variant relationships established between related dishes
  </done>
</task>

<task type="auto">
  <name>Task 2: Build query API, test suite, and mobile export</name>
  <files>
    knowledge-graph/query.py
    knowledge-graph/export_mobile.py
    knowledge-graph/tests/test_queries.py
  </files>
  <action>
Create the query layer and mobile export:

1. Create `knowledge-graph/query.py` with functions for all required graph traversals:

   a. `get_ingredients(dish_name: str) -> list[dict]`:
      - Use recursive CTE to find all ingredients for a dish INCLUDING its canonical variant's ingredients
      - Return: [{name, weight_pct, typical_amount_g, usda_fdc_id, is_nutrition_significant, source, confidence}]
      - Sort by weight_pct descending
      - Only return `is_nutrition_significant=True` items by default, with optional flag to include all

   b. `search_dish(query: str) -> list[dict]`:
      - Use FTS5 full-text search on dishes_fts
      - Return top 10 matches: [{id, name, cuisine, confidence}]
      - Support prefix matching ("fried ri*" matches "fried rice")

   c. `get_variants(dish_name: str) -> list[dict]`:
      - Find all dishes that share the same canonical_id or are canonical for the given dish
      - Return: [{id, name, cuisine}]

   d. `get_best_guess(partial_name: str) -> dict`:
      - Implements the "best-guess for unknown foods" locked decision
      - Try exact match first, then FTS5 prefix search, then trigram similarity
      - Always return SOMETHING (closest match) rather than None
      - Return: {name, cuisine, confidence, match_type: "exact"|"prefix"|"fuzzy"}

   e. `get_cuisine_stats() -> dict`:
      - Return cuisine distribution: {cuisine: {dish_count, ingredient_count}}

2. Create `knowledge-graph/tests/test_queries.py`:
   - Test `get_ingredients("fried rice")` returns rice, egg, oil, soy sauce at minimum
   - Test `get_ingredients("carbonara")` returns pasta, egg, pancetta/bacon, parmesan, black pepper
   - Test `search_dish("pad")` returns "pad thai" in results
   - Test `get_best_guess("xyznonexistent")` returns SOMETHING (not None/empty)
   - Test `get_variants("nasi goreng")` includes "fried rice" (or vice versa)
   - Test that recursive CTE traverses variant chain: if A is variant of B, querying A returns ingredients from both A and B

3. Create `knowledge-graph/export_mobile.py`:
   - Copy the knowledge graph DB to `knowledge-graph/food-knowledge-mobile.db`
   - Run VACUUM to optimize file size
   - Run ANALYZE to update query planner statistics
   - Remove any large temporary/cache tables if present
   - Print final DB file size (should be <50MB for mobile bundling)
   - Copy to `apps/mobile/src/data/food-knowledge.db` (the path where the mobile app will bundle it)
   - Print summary: total dishes, total ingredients, total relationships, file size
  </action>
  <verify>
- `python -m pytest knowledge-graph/tests/test_queries.py -v` passes all tests
- `python knowledge-graph/export_mobile.py` produces `food-knowledge-mobile.db` under 50MB
- `sqlite3 knowledge-graph/food-knowledge-mobile.db "SELECT i.name FROM dish_ingredients di JOIN ingredients i ON i.id = di.ingredient_id JOIN dishes d ON d.id = di.dish_id WHERE d.name LIKE '%carbonara%' ORDER BY di.weight_pct DESC LIMIT 5"` returns sensible ingredients
- `apps/mobile/src/data/food-knowledge.db` exists
  </verify>
  <done>
- Query API provides ingredient lookup, dish search, variant traversal, and best-guess matching
- All tests pass confirming correct recursive CTE behavior and FTS5 search
- Mobile-ready SQLite export is <50MB and copied to the mobile app's data directory
- Best-guess function always returns a result (never "unrecognised") per locked decision
  </done>
</task>

</tasks>

<verification>
- Knowledge graph contains >1000 dishes spanning at least 5 cuisine groups
- Recursive CTE correctly traverses variant relationships
- FTS5 search returns relevant results for partial dish names
- Mobile export is a valid, optimized SQLite file under 50MB
- Test suite passes confirming all query functions work correctly
</verification>

<success_criteria>
- SQLite knowledge graph seeded with RecipeNLG + USDA data
- Query functions return full ingredient breakdowns for common dishes (carbonara, fried rice, pad thai, etc.)
- Best-guess matching never returns empty (always suggests closest known dish)
- Mobile-ready export exists at apps/mobile/src/data/food-knowledge.db
</success_criteria>

<output>
After completion, create `.planning/phases/01-food-detection-foundation/01-02-SUMMARY.md`
</output>
